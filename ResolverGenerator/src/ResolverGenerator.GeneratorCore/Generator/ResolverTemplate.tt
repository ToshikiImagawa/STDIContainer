<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY STDIC(Static tree DIContainer). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618 // CS0618
#pragma warning disable 612 // CS0612
#pragma warning disable 414 // CS0414
#pragma warning disable 168 // CS0168

#pragma warning disable SA1649
#pragma warning disable SA1312
#pragma warning disable SA1200

namespace <#= Namespace #>
{
    public class <#= ResolverName #> : global::STDIC.IResolver
    {        
        public global::System.Collections.Generic.IEnumerable<global::System.Type> HasInjectConstructorTypes =>
            <#= ResolverName #>GetConstructorHelper.Keys;

        public global::STDIC.IConstructor<T> GetConstructor<T>()
        {
            return ConstructorCache<T>.Constructor;
        }

        private static class ConstructorCache<T>
        {
            public static readonly global::STDIC.IConstructor<T> Constructor;

            static ConstructorCache()
            {
                Constructor = (global::STDIC.IConstructor<T>)<#= ResolverName #>GetConstructorHelper.GetConstructor(typeof(T));
            }
        }
    }

    internal static class <#= ResolverName #>GetConstructorHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, int>
            ConstructorMap = new global::System.Collections.Generic.Dictionary<global::System.Type, int>()
            {
<#
    for (var i = 0; i < ConstructorInfos.Length; i++)
    {
        var constructorInfo = ConstructorInfos[i];
#>
                // <#= constructorInfo.FullName #>
                { typeof(<#= constructorInfo.FullName #>), <#= i #> },
<#
    }
#>
            };

        internal static global::System.Collections.Generic.IEnumerable<global::System.Type> Keys => ConstructorMap.Keys;

        internal static global::STDIC.IConstructor GetConstructor(global::System.Type t)
        {
            if (!ConstructorMap.TryGetValue(t, out var index)) return null;
            return index switch
            {
<#
    for (var i = 0; i < ConstructorInfos.Length; i++)
    {
        var constructorInfo = ConstructorInfos[i];
#>
                <#= i #> => new <#= constructorInfo.ConstructorName #>(),
<#
    }
#>
                _ => null
            };
        }
    }
}

#pragma warning restore 618 // CS0618
#pragma warning restore 612 // CS0612
#pragma warning restore 414 // CS0414
#pragma warning restore 168 // CS0168

#pragma warning restore SA1649
#pragma warning restore SA1312
#pragma warning restore SA1200